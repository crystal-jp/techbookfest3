Title: Crystalと日本語
Author: AKJ / @arcage

CrystalはRubyの影響を強く受けているだけあって、強力なテキスト処理の機能を持っています。

単純な数値計算と比べると実行速度の差は出にくいですが、以前、仕事関係で毎日1億行吐かれるログを集計する必要に迫られた際、Rubyで1時間半かかっていた1日分の処理が、最適化など考えずほぼそのままCrystalへ移植した結果25分になった、という経験をしました。以来、アドホックなログ解析など中心にCrystalをテキスト解析業務でも使用しています。

最近のUNIX系サーバが出力するログなどは基本的にASCIIオンリー、マルチバイト文字が入っていても大抵はUTF-8なので、Crystalの標準的な機能で何も問題はないのですが、日本語テキスト（Windows環境で作られたシフトJISのCSVファイルとか）を扱おうとすると、微妙な挙動に悩まされることがあります。

ここでは、そうした非UTF-8テキストを扱う場合のちょっとしたTipsをお送りします。

なお、本稿はCrystal 0.23.1をベースに執筆されています。また、各種コマンドの実行はmacOS sierra 10.12.6標準のbash上で行なっています。Crystalのバージョンやシェル環境の違いによって、記載内容との齟齬が生じる可能性がありますのでご注意ください。

# Crystalとエンコーディング

日本語テキストを扱おうとすると避けては通れないのがエンコーディング（文字コード）問題です。

UTF-8の普及に伴って多くのプログラム言語がUTF-8を標準エンコーディングとして採用していますので、いずれは「テキストデータとは、よほどの特殊用途でない限りUTF-8でエンコードされたデータのことである」という世界が来るのかもしれませんが、現時点ではさすがにそこまでエンコーディングの統一は進んではいません。Windowsのメモ帳をはじめとしたMicrosoft系アプリケーションがデフォルトでシフトJIS（正確にはCP932）を使用したり、日本語のメールがISO-2022-jpだったり、 EUC-JPやシフトJISのWebコンテンツが散在していたりと、まだまだエンコーディングを意識しておかなければならい場面が数多くあります。

Crystalも標準のエンコーディングは御多分に洩れずUTF-8です。ソースコードはUTF-8で記述されねばならず、テキストデータを扱う`String`型や`Char`型は、内部データとしてUTF-8エンコードされたバイト列を保持します。実際、ごく初期のCrystalはUTF-8以外のエンコーディングにまったく対応しておらず、シフトJISで書かれたファイルから文字列を読み込もうとするとエラーになったりもしていました。さすがに現在ではそのようなことはなく、適切な手順を踏めば大抵の場合、問題なくUTF-8以外の文字列を処理することができます。

## エンコーディングを指定する引数

Crystalが標準ライブラリで提供する型のメソッドの中には、引数として`encoding: String`と`invalid: Symbol?`をセットで指定できるものがあります。これらの引数は、そのメソッドが使用するエンコーディング（`encoding`）と、指定したエンコーディングにとって不正なバイト列が登場した場合の対処方法（`invalid`）を指定するものです。

引数`encoding`にはエンコーディング名を文字列で指定します。Crystalは文字エンコード処理にiconvライブラリを使用していますので、指定可能なエンコーディング名については、ご利用の環境で`iconv -l`を実行してみてください。このコマンドの出力結果（100行以上あります）の1行が1つのエンコーディングに対応しており、1行の中にスペースで区切られた複数の文字列がある場合は、それらのどれを指定しても同じエンコーディングとして扱われます。例えば、macOS sierra 10.12.6標準のiconvではシフトJISを指定するのに`MS_KANJI` `SHIFT-JIS` `SHIFT_JIS` `SJIS` `CSSHIFTJIS`といった文字列が使用可能なようです。また、iconvはエンコーディング名の大文字/小文字を区別しませんので、`SJIS`の代わりに`sjis`を指定したり、`Shift_JIS`や`MS_Kanji`を指定したりしても同じ結果になります。

一方、引数`invalid`には`Symbol`型の`:skip`もしくは`nil`のみが指定可能で、前者の場合は不正なバイト列が登場した際にそれらを無視し、後者の場合は例外を発生させます。ほとんどの場合、`invalid`にはデフォルト値（`nil`）が設定されていますので省略が可能です。

#### エンコーディングを指定可能なメソッド

* `File.each_line`
* `File.new`
* `File.open`
* `File.read`
* `File.read_lines`
* `File.write`
* `IO#set_encoding`
* `String.new`
* `String#encode`

## 入出力とエンコーディング

ソースコードも内部データもUTF-8ですので、非UTF-8テキストを扱うシーンの多くは外部との入出力、ということになります。

CrystalでいわゆるIOの機能を持つ型（標準入出力やファイル、ソケットなど）は`IO`モジュールをインクルードしています。それらはテキストデータの入出力に使用するエンコーディング情報を持っており、エンコーディングを変更する`IO#set_encoding`メソッドと、現在のエンコーディングを確認する`IO#encoding`メソッドを利用可能です。

`IO#set_encoding`メソッドで指定されたエンコーディングは、`IO`オブジェクトのインスタンスメソッドで入出力対象のエンコーディングとして使用されます。もしエンコーディングがシフトJISであると設定されれば、入力メソッド（`#gets`、`#gets_to_end`、`#read_char`）は入力データをシフトJISであるものとしてUTF-8に変換した文字列を返し、出力メソッド（`#<<`、`#print`、`#puts`、`#printf`）は出力文字列をシフトJISへ変換して書き出すようになります。こうすることで、内部的にはUTF-8のみを扱いながら、異なるエンコーディングの外部データを処理することが可能になっています。

なお、`#read`、`#write`および、`#read_byte`、`#write_byte`はテキストデータではなくバイトデータを入出力するためのメソッド（`String`型でなく`UInt8`型や`Bytes`型を扱うもの）なので、エンコーディングの影響を受けません。

`IO#encoding`メソッドはその時指定されているエンコーディング名を返します（デフォルトは`"UTF-8"`）。確認できるのはエンコーディング名（`encoding`）のみで、不正なバイト列への対処方法（`invalid`）については、現状では確認手段がないようです。また、`IO#set_encoding`メソッドでエンコーディングが変更されていた場合は、`IO#set_encoding`に与えられたエンコーディング名がそのまま返されます。そのため、`io.set_encoding("Shift_JIS")`と`io.set_encoding("SJIS")`はどちらも入出力の際のエンコーディングをシフトJISに変更しますが、その後に`io.encoding`を実行すると、前者の場合は`"Shift_JIS"`が、後者の場合は`"SJIS"`が返されます。

#### エンコーディングの変更と確認

```crystal
STDIN.set_encoding(encoding: "Shift_JIS", invalid: :skip)

STDIN.encoding
#=> "Shift_JIS"
```

#### シフトJISテキストの読み込み

```crystal
# read_sjis.cr
STDIN.set_encoding(encoding: "Shift_JIS", invalid: :skip)
p gets
```

実行結果：
```shell
$ hexdump sjis.txt
0000000 61 62 63 93 fa 96 7b 8c ea 0a
       ( a  b  c   日    本    語   \n)
$ crystal read_sjis.cr < sjis.txt
"abc日本語"
```

#### シフトJISテキストの書き出し

```crystal
# write_sjis.cr
STDOUT.set_encoding(encoding: "Shift_JIS")
puts "abc日本語"
```

実行結果：
```shell
$ crystal write_sjis.cr | hexdump
0000000 61 62 63 93 fa 96 7b 8c ea 0a
       ( a  b  c   日    本    語   \n)
```

### `File`型に対するエンコーディング指定

ファイルへのテキスト入出力を行うことが多いFile型では、`File.new`や`File.open`でファイルを開いてから`#set_encoding`メソッドを使用する以外にも、以下のクラスメソッドに対して直接エンコーディングの指定が可能です。

`.new`、`.open`、`.each_line`、`.read`、`.read_lines`、`.write`

#### ファイルからのシフトJISテキスト入出力

```crystal
# file_encoding.cr

File.open("sjis.txt", encoding: "Shift_JIS", invalid: :skip) do |f|
  puts f.gets
end

File.open("sjis2.txt", "w", encoding: "Shift_JIS") do |f|
  f.puts "abc日本語"
end
```

```shell
$ crystal file_encoding.cr
abc日本語
$ hexdump sjis2.txt
0000000 61 62 63 93 fa 96 7b 8c ea 0a
       ( a  b  c   日    本    語   \n)
```

### テキスト入出力に関する微妙な挙動

Crystalの標準的なエンコーディングはUTF-8です。確かに、`IO`系の型の初期状態に対する`#encoding`メソッドは`"UTF-8"`を返します。しかしこの時、実際には`IO`型の内部にはエンコーディング情報は存在していません。この状態では入出力データに対して一切のエンコーディング変換は行われず、不正なバイト列のチェックも行われません。そのため、エンコーディングを指定しない状態で`IO#gets`などを実行した場合、入力データがUTF-8であることを前提として、仮に不正なバイト列があったとしてもそれらを含んだ文字列が返されます。

では、明示的に`io.set_encoding("UTF-8", nil)`を実行した場合はどうでしょう？ `invalid`引数の定義からするとUTF-8として不正なバイト列に対して例外を発生させてくれそうに思いますが、実際にはそうはならず、やはり不正なバイト列を含んだ文字列が返されます。どうしてこのような動きになるかといえば、`IO#set_encoding`メソッドは`encoding`引数に`"UTF-8"`を、`invalid`引数に`:skip`以外（`nil`を含む）を指定して実行された場合に、内部のエンコーディング情報をクリアしてしまうからです。この挙動は`IO#set_encoding`以外の`encoding`引数、`invalid`引数を指定できるメソッドについても同様です。

`encoding`引数が`"UTF-8"`以外だったり、`encoding`引数が`"UTF-8"`だったとしても`invalid`引数が`:skip`だった場合には、指定した通りのエンコーディング情報が設定されます。例えば、`io.set_encoding("UTF-8", :skip)`とした場合は、UTF-8として不正なバイト列が取り除かれた文字列が返されますし、`io.set_encoding("Shift_JIS", nil)`とすれば、シフトJISとして不正なバイト列を含む入力には例外が発生します。

さらにややこしいのは、エンコーディング情報がクリアされるための`encoding`引数の条件が「結果として指定されたエンコーディングがUTF-8であること」ではなく「指定されたエンコーディング名が`"UTF-8"`という文字列であること」なので、`io.set_encoding("utf-8", nil)`を実行すると、UTF-8として不正なバイト列に対して例外が発生するようになります。

この問題が顕在化する場面は少ないかもしれませんが、場合によっては注意が必要です。

#### エンコーディング指定の挙動

```crystal
File.read("sjis.txt")
#=> "abc\x93\xFA\x96{\x8C\xEA\n"

File.read("sjis.txt", encoding: "UTF-8", invalid: nil)
#=> "abc\x93\xFA\x96{\x8C\xEA\n"

File.read("sjis.txt", encoding: "UTF-8", invalid: :skip)
#=> "abc{\n"

File.read("sjis.txt", encoding: "utf-8", invalid: nil)
#=> Invalid multibyte sequence (ArgumentError)
```

#### 参考：`IO#set_encoding`の実装（v0.23.1）

```crystal
module IO

  #...

  def set_encoding(encoding : String, invalid : Symbol? = nil)
    if (encoding == "UTF-8") && (invalid != :skip)
      @encoding = nil
    else
      @encoding = EncodingOptions.new(encoding, invalid)
    end
    @encoder.try &.close
    @decoder.try &.close
    @encoder = nil
    @decoder = nil
    nil
  end

  #...

end
```

## `String`型とエンコーディング

Crystalでテキストデータを扱う基本的な型は、文字列を表すString型です。

前述の通り、`String`型は基本的に内部データをUTF-8であるものとして扱います。ソースコードはUTF-8なので文字列リテラルも当然UTF-8ですし、入出力から`String`オブジェクトが生成される際にはUTF-8へ変換されますので、テキストデータの取り回しでUTF-8以外のエンコーディングを意識しなければならないシーンは多くはありません。

しかし、何らかの理由でUTF-8以外でエンコードされたバイト列から文字列を生成したくなったり、UTF-8以外でエンコードされたバイト列が必要になる場面もないではありません。そのため、バイト列（`Bytes`型）から文字列を生成する`String.new`メソッドの引数（`encoding`, `invalid`）で文字エンコードを指定したり、`String#encode`で内部データを特定のエンコーディングに変換したバイト列を取得することができます。

例えば、非UTF-8テキストをBase64でエンコード/デコードしたい場合などはそうした特殊な場面の一例です。`Base64`モジュールは（少なくともv0.23.1時点ではまだ）マルチエンコーディングに対応していませんので、プログラムの実装側で文字エンコードの変換を意識する必要があります。

#### シフトJISテキストのBase64エンコード

```crystal
require "base64"

utf_string = "abc日本語"

sjis_bytes = utf_string.encode("Shift_JIS")
#=> Bytes[97, 98, 99, 147, 250, 150, 123, 140, 234]

b64_encoded = Base64.encode(sjis_bytes)
#=> "YWJjk/qWe4zq\n"
```

#### Base64エンコードされたシフトJISテキストのデコード

```crystal
require "base64"

b64_encoded = "YWJjk/qWe4zq\n"

decoded_bytes = Base64.decode(b64_encoded)
#=> Bytes[97, 98, 99, 147, 250, 150, 123, 140, 234]

decoded_string = String.new(decoded_bytes, encoding: "Shift_JIS")
#=> "abc日本語"
```

### UTF-8として不正なバイト列の保持

CrystalがUTF-8以外でエンコードされたデータの入出力に対応してからも、しばらくの間は文字列（`String`オブジェクト）ではUTF-8として正しいバイト列しか保持することができませんでした。しかし、現在では`String.new`メソッドの一部（`Bytes`型のデータを指定できるもの）や`String.build`メソッドなどを介して生成した文字列は、内部データにUTF-8としては不正なバイト列が含まれていてもエラーを発生させません。

このように曲がりなりにも文字列が内部データとして不正なバイト列を保持できるようになったのは、Crystal v0.21.0(20-02-2017) 以降ですので、（執筆時点からすると）実は割と最近の出来事です。

依然として、`String`型はUTF-8エンコードされたデータを保持するのが前提であるにも関わらず、不正なバイト列を保持できるようにわざわざ改修された理由は、現実問題として世の中には厳密な意味ではUTF-8に準拠していないデータが氾濫しており、そうしたデータと遭遇するたびにエラーでプログラムが停止してしまうことのデメリットを考慮した結果だそうです。実際、この改修が入る前には、サイボウズGaroon APIが返すXMLが`invalid encoding: "utf-8" (ArgumentError)`を引き起こして頭を抱えた経験もありますので、そうした状況が他にも存在することを思えば妥当な判断といえるでしょう。

文字列が不正なバイト列を含んでいるかどうかは`String#valid_encoding?`メソッドで確認することができます。このメソッドはレシーバとなる文字列が不正なバイト列を含んでいなければ`true`を、含んでいれば`false`を返します。`String`オブジェクトの内部データに不正なバイト列が含まれている場合に、`String#[](index: Int)`、`String#char_at`、`String#chars`などによって不正なバイト列に相当する位置の文字（`Char`オブジェクト）を取得しようとすると、その文字は`Char::REPLACEMENT`(`'\xFFFD'`、`'�'`)に置き換えられます。また、`String#scrub(replacement)`メソッドを使用すると、不正なバイト列に相当する文字が全て`replacement`引数（デフォルト値は`Char::REPLACEMENT`）の値に置き換えられた文字列を取得することができます。なお、Crystalの文字列は不変（immutable）なオブジェクトですので、自身を破壊的に変更するようなメソッドは存在しません。文字列変数から不正なバイト列を除去したい場合は、`String#scrub`の値を再代入してください。

Rubyでは`File.binread`が`String`クラスのオブジェクトを返してくるなど、バイト列の格納に`String`クラスを使用したりしますが、Crystalではバイト列の取り扱いは基本的には`Bytes`型（`Slice(UInt8)`の別名）の領分ですので、たとえ`String`オブジェクトの内部データとして不正なバイト列を保持できるようになったとはいえ、そうした状態はどちらかといえばイレギュラーな状況だと思います。

#### 不正なバイト列の見え方

```crystal
invalid_string = File.read("sjis.txt")

invalid_string.inspect
#=> "abc\x93\xFA\x96{\x8C\xEA\n"

invalid_string.valid_encoding?
#=> false

invalid_string.chars
#=> ['a', 'b', 'c', '�', '�', '{', '�', '�', '\n']

invalid_string.scrub('？')
#=> "abc？？{？？\n"
```

## `Char`型とエンコーディング

UTF-8としてエンコードされた文字の一連の並びを保持する`String`型に対して、UTF-8の特定のコードポイント1つ（1文字）だけを表すのが`Char`型です。Char型の内部データはUTF-8のコードポイントを保持するための`UInt32`型の値があるだけで、基本的にエンコーディングを考慮しません。

そのため、いくつかの場面でUTF-8のコードポイントとしては不正な値を持った`Char`オブジェクトが生成されてしまいます。`Char`型には`String#valid_encoding?`のように自身がUTF-8的に正しいコードポイントであるかどうかをチェックするメソッドなども無いようなので、その点には注意が必要かもしれません。

#### 不正なコードポイントを持った`Char`が生成される例

* `Char`リテラルに16進表記で不正なコードポイントを指定した場合（`'\u{1274}'`）
* `Int#chr`でコードポイントとしては不正な数値から`Char`オブジェクトを生成した場合（`1247.char`）
* `IO#read_char`や`IO#each_char`でUTF-8エンコード以外の外部データから1文字だけを取り出して処理する場合

# おまけ1：Crystalと改行コード

テキスト処理において、エンコーディングと並んで環境による差が出やすいのが、行と行の区切りに用いられるいわゆる「改行コード」です。

ASCIIベースの環境では、改行コードとしてASCII文字のCR（`0x0C`、`'\r'`）とLF（`0x0A`、`'\n'`）を連続して使用する場合、LFのみを単独で使用する場合、CRのみを使用する場合の3パターンがよく知られています。このうち、CR+FLは主にWindows OSで、LF単独はLinuxやMac OS（OSX以降）などのUNIX系OSでそれぞれ現在でも頻繁に目にします。CRのみを改行コードとする環境には古いMac OS（OS9以前）などがありましたが、こちらは他の2パターンと比べるとあまり一般的ではないようです。

さて、2017年9月現在、Crystalは基本的にUNIX系OSに向けて提供されています。そういったわけで、Crystalで暗黙的に改行が出力される場面（`IO#puts`など）では、`'\n'`（LF）が出力されます。これは、Ubuntu on Windows上にインストールされたCrystalでも同様です。

一方、入力テキストの改行処理はというと、`IO#gets`が使用するデフォルトの区切り文字が`'\n'`であるところからして、やはりLFが標準的な改行コードであるようです。ただし、行末の改行コードを除去する`chomp`系の処理では、行区切り文字として`'\n'`を指定しており、かつ`'\n'`の直前の文字が`'\r'`である場合には、`'\r'`と`'\n'`がまとめて除去されるため、改行コードがCR+LFであるテキストも正しく処理されます。

Crystalコンパイラも基本的に`'\n'`をプログラムの改行コードとして認識していますが、`'\n'`の直前の文字が`'\r'`であればやはりまとめて改行として処理します。ただし、後ろに`'\n'`が続かない`'\r'`がプログラム中に登場した場合にはコンパイルエラー（`Syntax error: expected '\n' after '\r'`）が発生します。

というわけで、Crystalにとって改行コードとは「基本的にLF単体のことではあるが、CR+LFについては配慮している。CR単体は知らん」ということのようです。

# おまけ2：Crystalとエスケープシーケンス

Crystalの`String`型や`Char`型では、リテラルの中にコントロールコードなどを埋め込むためのエスケープシーケンスが利用可能です。どちらもバックスラッシュ（`\`）に続けて所定の文字列を指定する点では共通していますが、両者が指定できるエスケープシーケンスの種類は微妙に異なっていますので注意が必要です。

両者の一番大きな違いは、コンパイラ側で特に定義されていないエスケープシーケンスの挙動です。ダブルクォート（`"`）で括る形式の標準的な`String`リテラルでは、未定義のバックスラッシュによるエスケープは、次の文字そのもの（`"\a"`は`"a"`と等価）として評価されます。そのため、どの文字の前にバックスラッシュをおいても基本的にエラーにはなりません。例えば、`String`リテラルの評価ではバックスラッシュやダブルクォートのエスケープもこの流れで処理されるため、`"\\"`や`"\""`を処理するための個別の定義はありません。

一方、`Char`リテラル内で未定義のエスケープシーケンスを使用するとコンパイルエラーが発生します。そのため`Char`リテラルの評価では`'\\'`や`'\''`についての個別定義が存在しています。

この他にも、`Char`型ではヌル文字（`'\0'`）以外の10進表記によるコードポイント指定や、`\x`に続けて16進表記で1バイト分（2文字）のコードポイントを指定する方法が利用できないなどの違いがあります。

標準的な`String`/`Char`リテラルで使用できるエスケープシーケンスは以下の通りです。

#### `String`リテラルで利用できるエスケープシーケンス

* `"\b"` : バックスペース
* `"\n"` : ラインフィード
* `"\r"` : キャリッジリターン
* `"\t"` : 水平タブ
* `"\v"` : 垂直タブ
* `"\f"` : 改ページ
* `"\e"` : エスケープ
* `"\10"` : コードポイント10進表記
* `"\x0A"` : `x` + コードポイント16進表記2文字（1バイト）固定
* `"\u000A"` : `u` + コードポイント16進表記4文字（2バイト）固定
* `"\u{A}"` : `u` + `{}`で括ったコードポイント16進表記1〜6文字（0パディング不要）
* `\` + 改行 : 改行と続く空白文字を無視
* その他 : バックスラッシュに続く文字をそのまま使用（`"\\"`, `"\""`など）

#### `Char`リテラルで利用できるエスケープシーケンス

* `'\\'` : バックスラッシュ
* `'\''` : シングルクォート
* `'\b'` : バックスペース
* `'\n'` : ラインフィード
* `'\r'` : キャリッジリターン
* `'\t'` : 水平タブ
* `'\v'` : 垂直タブ
* `'\f'` : 改ページ
* `'\e'` : エスケープ
* `'\0'` : ヌル文字
* `'\u000A'` : `u` + コードポイント16進表記4文字（2バイト）固定
* `'\u{A}'` : `u` + `{}`で括ったコードポイント16進表記1〜6文字（0パディング不要）
* その他 : コンパイルエラー（`Syntax error: invalid char escape sequence`）

# さいごに

毎回同じようなことを書いていますが、Crystalの大きな魅力の1つはセルフホスティングな言語である（Crystalコンパイラ自身がCrystalで書かれている）という点だと思います。

Crystalに限った話ではありませんが、プログラムを書いているとエラーにならないけれど想定外の動きをする、という状況に間々遭遇します。今回、この原稿を書いている間にも引数`invalid`の挙動には少々悩まされました。

そんな時、Crystalはコンパイラや標準添付ライブラリ自身がCrystal自身で書かれているので、GitHub上にあるCrystal本体のソースコードリポジトリを追いかけていくと、それらが何故そのような挙動を示すのか解明できたりします。

本稿で書かれている内容は以下のソースコードなどで確認できますので、興味があれば覗いてみてください。

では皆さん、楽しいCrystalライフを。

* https://github.com/crystal-lang/crystal/blob/master/src/io.cr

    `IO#set_encoding`の挙動や改行コードの処理など

* https://github.com/crystal-lang/crystal/blob/master/src/string.cr

    `String`クラスのでの不正なバイト列の扱いなど

* https://github.com/crystal-lang/crystal/blob/master/src/compiler/crystal/syntax/lexer.cr

    `String`/`Char`リテラル内のエスケープシーケンス処理など
